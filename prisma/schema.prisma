generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(uuid())
  auth0Id     String   @unique @map("auth0_id")
  email       String   @unique
  username    String   @unique
  firstName   String   @map("first_name")
  dateOfBirth DateTime @map("date_of_birth")
  avatarUrl   String?  @map("avatar_url") // User profile avatar image URL
  createdAt   DateTime @default(now()) @map("created_at")
  oneSignalPlayerId String? @map("onesignal_player_id") // OneSignal player ID for push notifications
  
  createdRooms    Room[] @relation("RoomCreatedBy")
  roomsNamedBy    Room[] @relation("RoomNameSetBy")
  roomParticipants RoomParticipant[]
  elements           Element[]
  messages           Message[]
  messageReactions   MessageReaction[]
  messageReads       MessageRead[]
  elementReactions   ElementReaction[]
  elementComments    ElementComment[]
  commentLikes       CommentLike[]
  
  // Following relationships
  followers    Follow[] @relation("UserFollowing") // People who follow me
  following    Follow[] @relation("UserFollowers") // People I follow
  
  // Denormalized counts for performance
  followersCount  Int @default(0) @map("followers_count")
  followingCount  Int @default(0) @map("following_count")
  
  @@map("users")
}

model Room {
  id           String   @id @default(uuid())
  name         String   // Required room name
  nameSetBy    String?  @map("name_set_by") // User who set the room name
  nameSetByUser User?   @relation("RoomNameSetBy", fields: [nameSetBy], references: [id])
  createdBy    String   @map("created_by")
  creator      User     @relation("RoomCreatedBy", fields: [createdBy], references: [id])
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at") // Track when room content is updated (elements, name, etc)
  messagesUpdatedAt DateTime? @map("messages_updated_at") // Track when messages were last sent/deleted
  isActive     Boolean  @default(true) @map("is_active")
  isPublic     Boolean  @default(false) @map("is_public") // Room visibility: false = private (default), true = public
  
  participants RoomParticipant[]
  elements     Element[]
  messages     Message[]
  comments     ElementComment[]
  
  @@map("rooms")
}

model RoomParticipant {
  roomId         String    @map("room_id")
  userId         String    @map("user_id")
  room           Room      @relation(fields: [roomId], references: [id])
  user           User      @relation(fields: [userId], references: [id])
  joinedAt       DateTime  @default(now()) @map("joined_at")
  leftAt         DateTime? @map("left_at") // Track when user left
  lastVisitedAt  DateTime  @default(now()) @map("last_visited_at") // Track when user last visited room
  lastReadAt     DateTime  @default(now()) @map("last_read_at") // Track when user last read messages
  color          String    // Hex color for touch circle
  isActive       Boolean   @default(true) @map("is_active")
  
  @@id([roomId, userId])
  @@index([userId]) // Speed up participant lookups
  @@map("room_participants")
}

model Element {
  id         String    @id @default(uuid())
  roomId     String    @map("room_id")
  room       Room      @relation(fields: [roomId], references: [id])
  type       ElementType
  createdBy  String    @map("created_by")
  creator    User      @relation(fields: [createdBy], references: [id])
  positionX  Float     @map("position_x")
  positionY  Float     @map("position_y")
  content    String?   // For notes and horoscopes
  imageUrl   String?   @map("image_url") // For photos
  audioUrl   String?   @map("audio_url") // For audio/voice notes
  videoUrl   String?   @map("video_url") // For videos
  thumbnailUrl String? @map("thumbnail_url") // For video thumbnails
  duration   Float?    // Audio/video duration in seconds
  width      Float
  height     Float
  rotation   Float     @default(0) @map("rotation") // Rotation in degrees (0-360)
  scaleX     Float     @default(1) @map("scale_x") // Horizontal scale factor
  scaleY     Float     @default(1) @map("scale_y") // Vertical scale factor
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  deletedAt  DateTime? @map("deleted_at")
  
  reactions  ElementReaction[]
  comments   ElementComment[]
  
  @@map("elements")
}

enum ElementType {
  NOTE
  PHOTO
  AUDIO
  HOROSCOPE
  VIDEO
  LINK
}

model Message {
  id         String    @id @default(uuid())
  roomId     String    @map("room_id")
  room       Room      @relation(fields: [roomId], references: [id])
  senderId   String    @map("sender_id")
  sender     User      @relation(fields: [senderId], references: [id])
  text       String    @db.Text // Allow longer messages
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  deletedAt  DateTime? @map("deleted_at") // Soft delete
  
  reactions  MessageReaction[]
  readBy     MessageRead[]
  
  @@index([roomId, createdAt]) // For efficient pagination
  @@map("messages")
}

model MessageReaction {
  messageId  String   @map("message_id")
  message    Message  @relation(fields: [messageId], references: [id])
  userId     String   @map("user_id")
  user       User     @relation(fields: [userId], references: [id])
  createdAt  DateTime @default(now()) @map("created_at")
  
  @@id([messageId, userId]) // One reaction per user per message
  @@map("message_reactions")
}

model MessageRead {
  messageId  String   @map("message_id")
  message    Message  @relation(fields: [messageId], references: [id])
  userId     String   @map("user_id")
  user       User     @relation(fields: [userId], references: [id])
  readAt     DateTime @default(now()) @map("read_at")
  
  @@id([messageId, userId])
  @@index([messageId]) // For efficient read receipt queries
  @@map("message_reads")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  follower    User     @relation("UserFollowers", fields: [followerId], references: [id])
  following   User     @relation("UserFollowing", fields: [followingId], references: [id])
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@unique([followerId, followingId]) // Prevent duplicate follows
  @@index([followerId]) // Fast lookup of who I follow
  @@index([followingId]) // Fast lookup of my followers
  @@map("follows")
}

model ElementReaction {
  id         String       @id @default(uuid())
  elementId  String       @map("element_id")
  element    Element      @relation(fields: [elementId], references: [id], onDelete: Cascade)
  userId     String       @map("user_id")
  user       User         @relation(fields: [userId], references: [id])
  emoji      String       @map("emoji") // Any emoji character(s)
  createdAt  DateTime     @default(now()) @map("created_at")
  
  @@unique([elementId, userId]) // One reaction per user per element
  @@index([elementId, createdAt]) // For efficient top reactors query
  @@map("element_reactions")
}

model ElementComment {
  id         String        @id @default(uuid())
  roomId     String        @map("room_id")
  room       Room          @relation(fields: [roomId], references: [id], onDelete: Cascade)
  elementId  String        @map("element_id")
  element    Element       @relation(fields: [elementId], references: [id], onDelete: Cascade)
  userId     String        @map("user_id")
  user       User          @relation(fields: [userId], references: [id])
  content    String        @db.VarChar(140) // Max 140 characters
  createdAt  DateTime      @default(now()) @map("created_at")
  updatedAt  DateTime      @updatedAt @map("updated_at")
  deletedAt  DateTime?     @map("deleted_at") // Soft delete
  
  likes      CommentLike[] // Likes on this comment
  
  @@index([elementId, createdAt(sort: Desc)]) // For paginated queries
  @@index([roomId])
  @@index([userId])
  @@map("element_comments")
}

model CommentLike {
  id         String         @id @default(uuid())
  commentId  String         @map("comment_id")
  comment    ElementComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId     String         @map("user_id")
  user       User           @relation(fields: [userId], references: [id])
  createdAt  DateTime       @default(now()) @map("created_at")
  
  @@unique([commentId, userId]) // One like per user per comment
  @@index([commentId])
  @@index([userId])
  @@map("comment_likes")
}